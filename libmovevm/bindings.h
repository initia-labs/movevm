/* (c) 2024 initia labs. Licensed under BUSL-1.1 */

#ifndef __LIBMOVEVM__
#define __LIBMOVEVM__

/* Generated with cbindgen:0.26.0 */

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>


enum libmovevm_ErrnoValue {
  libmovevm_ErrnoValue_Success = 0,
  libmovevm_ErrnoValue_Other = 1,
};
typedef int32_t libmovevm_ErrnoValue;

/**
 * This enum gives names to the status codes returned from Go callbacks to Rust.
 * The Go code will return one of these variants when returning.
 *
 * 0 means no error, all the other cases are some sort of error.
 *
 */
enum libmovevm_GoError {
  libmovevm_GoError_None = 0,
  /**
   * Go panicked for an unexpected reason.
   */
  libmovevm_GoError_Panic = 1,
  /**
   * Go received a bad argument from Rust
   */
  libmovevm_GoError_BadArgument = 2,
  /**
   * Error while trying to serialize data in Go code (typically json.Marshal)
   */
  libmovevm_GoError_CannotSerialize = 3,
  /**
   * An error happened during normal operation of a Go callback, which should be fed back to the contract
   */
  libmovevm_GoError_User = 4,
  /**
   * Unimplemented
   */
  libmovevm_GoError_Unimplemented = 5,
  /**
   * An error type that should never be created by us. It only serves as a fallback for the i32 to GoError conversion.
   */
  libmovevm_GoError_Other = -1,
};
typedef int32_t libmovevm_GoError;

typedef struct {

} libmovevm_VmT;

/**
 * A view into an externally owned byte slice (Go `[]byte`).
 * Use this for the current call only. A view cannot be copied for safety reasons.
 * If you need a copy, use [`ByteSliceView::to_owned`].
 *
 * Go's nil value is fully supported, such that we can differentiate between nil and an empty slice.
 */
typedef struct {
  /**
   * True if and only if the byte slice is nil in Go. If this is true, the other fields must be ignored.
   */
  bool is_nil;
  const uint8_t *ptr;
  size_t len;
} libmovevm_ByteSliceView;

/**
 * An optional Vector type that requires explicit creation and destruction
 * and can be sent via FFI.
 * It can be created from `Option<Vec<u8>>` and be converted into `Option<Vec<u8>>`.
 *
 * This type is always created in Rust and always dropped in Rust.
 * If Go code want to create it, it must instruct Rust to do so via the
 * [`new_unmanaged_vector`] FFI export. If Go code wants to consume its data,
 * it must create a copy and instruct Rust to destroy it via the
 * [`destroy_unmanaged_vector`] FFI export.
 *
 * An UnmanagedVector is immutable.
 *
 * ## Ownership
 *
 * Ownership is the right and the obligation to destroy an `UnmanagedVector`
 * exactly once. Both Rust and Go can create an `UnmanagedVector`, which gives
 * then ownership. Sometimes it is necessary to transfer ownership.
 *
 * ### Transfer ownership from Rust to Go
 *
 * When an `UnmanagedVector` was created in Rust using [`UnmanagedVector::new`], [`UnmanagedVector::default`]
 * or [`new_unmanaged_vector`], it can be passed to Go as a return value.
 * Rust then has no chance to destroy the vector anymore, so ownership is transferred to Go.
 * In Go, the data has to be copied to a garbage collected `[]byte`. Then the vector must be destroyed
 * using [`destroy_unmanaged_vector`].
 *
 * ### Transfer ownership from Go to Rust
 *
 * When Rust code calls into Go (using the vtable methods), return data or error messages must be created
 * in Go. This is done by calling [`new_unmanaged_vector`] from Go, which copies data into a newly created
 * `UnmanagedVector`. Since Go created it, it owns it. The ownership is then passed to Rust via the
 * mutable return value pointers. On the Rust side, the vector is destroyed using [`UnmanagedVector::consume`].
 *
 */
typedef struct {
  /**
   * True if and only if this is None. If this is true, the other fields must be ignored.
   */
  bool is_none;
  uint8_t *ptr;
  size_t len;
  size_t cap;
} libmovevm_UnmanagedVector;

typedef struct {
  uint8_t _private[0];
} libmovevm_DbT;

/**
 * A view into a `Option<&[u8]>`, created and maintained by Rust.
 *
 * This can be copied into a []byte in Go.
 */
typedef struct {
  /**
   * True if and only if this is None. If this is true, the other fields must be ignored.
   */
  bool is_none;
  const uint8_t *ptr;
  size_t len;
} libmovevm_U8SliceView;

typedef struct {
  /**
   * An ID assigned to this contract call
   */
  uint64_t call_id;
  uint64_t iterator_index;
} libmovevm_IteratorT;

typedef struct {
  int32_t (*next_db)(libmovevm_IteratorT, libmovevm_UnmanagedVector*, libmovevm_UnmanagedVector*);
} libmovevm_IteratorVTable;

typedef struct {
  libmovevm_IteratorT state;
  libmovevm_IteratorVTable vtable;
  size_t prefix_len;
} libmovevm_GoIter;

typedef struct {
  int32_t (*read_db)(libmovevm_DbT*,
                     libmovevm_U8SliceView,
                     libmovevm_UnmanagedVector*,
                     libmovevm_UnmanagedVector*);
  int32_t (*write_db)(libmovevm_DbT*,
                      libmovevm_U8SliceView,
                      libmovevm_U8SliceView,
                      libmovevm_UnmanagedVector*);
  int32_t (*remove_db)(libmovevm_DbT*, libmovevm_U8SliceView, libmovevm_UnmanagedVector*);
  int32_t (*scan_db)(libmovevm_DbT*,
                     libmovevm_U8SliceView,
                     libmovevm_U8SliceView,
                     libmovevm_U8SliceView,
                     int32_t,
                     libmovevm_GoIter*,
                     libmovevm_UnmanagedVector*);
} libmovevm_DbVTable;

typedef struct {
  libmovevm_DbT *state;
  libmovevm_DbVTable vtable;
} libmovevm_GoDb;

typedef struct {
  uint8_t _private[0];
} libmovevm_ApiT;

typedef struct {
  int32_t (*query)(const libmovevm_ApiT*,
                   libmovevm_U8SliceView,
                   uint64_t,
                   libmovevm_UnmanagedVector*,
                   uint64_t*,
                   libmovevm_UnmanagedVector*);
  int32_t (*get_account_info)(const libmovevm_ApiT*,
                              libmovevm_U8SliceView,
                              bool*,
                              uint64_t*,
                              uint64_t*,
                              uint8_t*,
                              bool*,
                              libmovevm_UnmanagedVector*);
  int32_t (*amount_to_share)(const libmovevm_ApiT*,
                             libmovevm_U8SliceView,
                             libmovevm_U8SliceView,
                             uint64_t,
                             libmovevm_UnmanagedVector*,
                             libmovevm_UnmanagedVector*);
  int32_t (*share_to_amount)(const libmovevm_ApiT*,
                             libmovevm_U8SliceView,
                             libmovevm_U8SliceView,
                             libmovevm_U8SliceView,
                             uint64_t*,
                             libmovevm_UnmanagedVector*);
  int32_t (*unbond_timestamp)(const libmovevm_ApiT*, uint64_t*, libmovevm_UnmanagedVector*);
  int32_t (*get_price)(const libmovevm_ApiT*,
                       libmovevm_U8SliceView,
                       libmovevm_UnmanagedVector*,
                       uint64_t*,
                       uint64_t*,
                       libmovevm_UnmanagedVector*);
} libmovevm_ApiVTable;

typedef struct {
  const libmovevm_ApiT *state;
  libmovevm_ApiVTable vtable;
} libmovevm_GoApi;

libmovevm_VmT *libmovevm_allocate_vm(libmovevm_ByteSliceView config_payload);

libmovevm_UnmanagedVector libmovevm_decode_module_bytes(libmovevm_UnmanagedVector *errmsg,
                                                        libmovevm_ByteSliceView module_bytes);

libmovevm_UnmanagedVector libmovevm_decode_move_resource(libmovevm_GoDb db,
                                                         libmovevm_UnmanagedVector *errmsg,
                                                         libmovevm_ByteSliceView struct_tag,
                                                         libmovevm_ByteSliceView resource_bytes);

libmovevm_UnmanagedVector libmovevm_decode_move_value(libmovevm_GoDb db,
                                                      libmovevm_UnmanagedVector *errmsg,
                                                      libmovevm_ByteSliceView type_tag,
                                                      libmovevm_ByteSliceView value_bytes);

libmovevm_UnmanagedVector libmovevm_decode_script_bytes(libmovevm_UnmanagedVector *errmsg,
                                                        libmovevm_ByteSliceView script_bytes);

void libmovevm_destroy_unmanaged_vector(libmovevm_UnmanagedVector v);

libmovevm_UnmanagedVector libmovevm_execute_authenticate(libmovevm_VmT *vm_ptr,
                                                         uint64_t *gas_balance_ptr,
                                                         libmovevm_GoDb db,
                                                         libmovevm_GoApi api,
                                                         libmovevm_ByteSliceView env_payload,
                                                         libmovevm_ByteSliceView sender,
                                                         libmovevm_ByteSliceView authenticate_payload,
                                                         libmovevm_UnmanagedVector *errmsg);

libmovevm_UnmanagedVector libmovevm_execute_contract(libmovevm_VmT *vm_ptr,
                                                     uint64_t *gas_balance_ptr,
                                                     libmovevm_GoDb db,
                                                     libmovevm_GoApi api,
                                                     libmovevm_ByteSliceView env_payload,
                                                     libmovevm_ByteSliceView senders,
                                                     libmovevm_ByteSliceView entry_function_payload,
                                                     libmovevm_UnmanagedVector *errmsg);

libmovevm_UnmanagedVector libmovevm_execute_script(libmovevm_VmT *vm_ptr,
                                                   uint64_t *gas_balance_ptr,
                                                   libmovevm_GoDb db,
                                                   libmovevm_GoApi api,
                                                   libmovevm_ByteSliceView env_payload,
                                                   libmovevm_ByteSliceView senders,
                                                   libmovevm_ByteSliceView script_payload,
                                                   libmovevm_UnmanagedVector *errmsg);

libmovevm_UnmanagedVector libmovevm_execute_view_function(libmovevm_VmT *vm_ptr,
                                                          uint64_t *gas_balance_ptr,
                                                          libmovevm_GoDb db,
                                                          libmovevm_GoApi api,
                                                          libmovevm_ByteSliceView env_payload,
                                                          libmovevm_ByteSliceView view_function_payload,
                                                          libmovevm_UnmanagedVector *errmsg);

libmovevm_UnmanagedVector libmovevm_initialize(libmovevm_VmT *vm_ptr,
                                               libmovevm_GoDb db,
                                               libmovevm_GoApi api,
                                               libmovevm_ByteSliceView env_payload,
                                               libmovevm_ByteSliceView module_bundle_payload,
                                               libmovevm_ByteSliceView allowed_publishers_payload,
                                               libmovevm_UnmanagedVector *errmsg);

libmovevm_UnmanagedVector libmovevm_new_unmanaged_vector(bool nil,
                                                         const uint8_t *ptr,
                                                         size_t length);

libmovevm_UnmanagedVector libmovevm_parse_struct_tag(libmovevm_UnmanagedVector *errmsg,
                                                     libmovevm_ByteSliceView struct_tag_str);

libmovevm_UnmanagedVector libmovevm_read_module_info(libmovevm_UnmanagedVector *errmsg,
                                                     libmovevm_ByteSliceView compiled);

void libmovevm_release_vm(libmovevm_VmT *vm);

libmovevm_UnmanagedVector libmovevm_stringify_struct_tag(libmovevm_UnmanagedVector *errmsg,
                                                         libmovevm_ByteSliceView struct_tag);

#endif /* __LIBMOVEVM__ */
